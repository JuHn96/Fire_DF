<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>통합 아키텍처 설명</title>
  <style>
    /* 2-C 공통 스타일 시작 */

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", system-ui, sans-serif;
      line-height: 1.7;
      margin: 0;
      padding: 32px 16px;
      color: #1f2937;
      background-color: #e5e7eb;
    }

    .page {
      max-width: 960px;
      margin: 0 auto;
      background-color: #ffffff;
      border-radius: 16px;
      padding: 28px 32px 32px;
      box-shadow: 0 10px 30px rgba(15, 23, 42, 0.12);
      border: 1px solid #e5e7eb;
    }

    h1, h2, h3 {
      margin-top: 0;
      color: #111827;
    }

    h1 {
      font-size: 30px;
      font-weight: 800;
      margin: 0 0 14px 0;
      letter-spacing: -0.03em;
      line-height: 1.3;
    }

    h2 {
      font-size: 22px;
      font-weight: 700;
      margin-bottom: 10px;
    }

    h3 {
      font-size: 18px;
      font-weight: 600;
      margin-top: 14px;
      margin-bottom: 8px;
    }

    .page-header {
      border-bottom: 1px solid #e5e7eb;
      padding-bottom: 12px;
      margin-bottom: 20px;
    }

    .tagline {
      font-size: 15px;
      color: #4b5563;
      margin: 0;
    }

    .section {
      position: relative;
      background: linear-gradient(to right, #ffffff, #fafafa);
      padding: 16px 20px 16px 28px;
      border-radius: 12px;
      margin-bottom: 22px;
      border: 1px solid #e5e7eb;
      box-shadow: 0 1px 2px rgba(15, 23, 42, 0.06);
    }

    .section::before {
      content: "";
      position: absolute;
      left: 10px;
      top: 16px;
      bottom: 16px;
      width: 4px;
      border-radius: 999px;
      background: linear-gradient(to bottom, #ede9fe, #c4b5fd, #818cf8);
    }

    ul {
      margin-top: 6px;
      margin-bottom: 6px;
      padding-left: 20px;
    }

    li {
      margin-bottom: 6px;
      font-size: 14px;
    }

    .summary-box {
      margin-top: 10px;
      padding: 14px 16px;
      border-radius: 10px;
      border-left: 5px solid #818cf8;
      background: linear-gradient(to right, #eef2ff, #f5f3ff);
      box-shadow: 0 1px 4px rgba(15, 23, 42, 0.12);
      font-size: 15px;
    }

    pre {
      background: #020617;
      color: #e5e7eb;
      padding: 14px;
      border-radius: 8px;
      overflow-x: auto;
      margin-top: 12px;
      margin-bottom: 12px;
      font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      border: 1px solid #111827;
    }

    code {
      font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      background-color: #f3f4ff;
      padding: 2px 5px;
      border-radius: 4px;
      border: 1px solid #e5e7eb;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 12px;
      margin-bottom: 18px;
    }

    table th, table td {
      border: 1px solid #d1d5db;
      padding: 8px 10px;
      font-size: 14px;
    }

    table th {
      background: #f3f4f6;
      font-weight: 600;
    }

    @media (max-width: 640px) {
      .page {
        padding: 20px 16px 22px;
        border-radius: 12px;
      }
      h1 { font-size: 24px; }
      h2 { font-size: 19px; }
    }

    /* 2-C 공통 스타일 끝 */
  </style>
</head>
<body>
  <div class="page">
    <header class="page-header">
      <h1>통합 아키텍처 설명</h1>
    </header>

    <div class="section">
      <h2>0. 이 장에서 다루는 범위</h2>
      <p>
        이 장은 본 프로젝트의 전체 시스템 구성을 <strong>컴포넌트 단위</strong>로 설명하고,
        각 요소가 어떻게 연결되어 <strong>실시간 화재 감지 → 알림 → 로그/통계</strong>까지 이어지는지
        아키텍처 관점에서 정리하는 챕터입니다.
      </p>
      <p>
        앞선 장들(DB, API, WebSocket, 카카오, 이벤트 플로우)은 각각의 기능을 세부적으로 설명했다면,
        이 장은 그것들을 <strong>“하나의 큰 그림”</strong>으로 묶어서 보는 역할을 합니다.
      </p>
    </div>

    <div class="section">
      <h2>1. 전체 구성 요소 개요</h2>
      <p>시스템은 크게 다음 레이어들로 나눌 수 있습니다.</p>
      <ul>
        <li><strong>현장 레이어</strong>: 기존 설치 CCTV, NVR, RTSP 스트림</li>
        <li><strong>AI 레이어</strong>: 화재 감지 모델이 동작하는 AI 서버(컨테이너)</li>
        <li><strong>백엔드 레이어</strong>: FastAPI 기반 BE 서버, WebSocket 서버, 카카오 연동 모듈</li>
        <li><strong>데이터 레이어</strong>: MySQL DB, 이벤트 이미지/캡처 스토리지</li>
        <li><strong>프론트엔드 레이어</strong>: Vue 기반 관리자 대시보드, Nginx 정적 서버</li>
        <li><strong>인프라 레이어</strong>: Docker / Docker Compose 를 통한 통합 실행 환경</li>
      </ul>
    </div>

    <div class="section">
      <h2>2. 현장 레이어 – CCTV 및 RTSP 스트림</h2>
      <ul>
        <li>기존에 설치되어 있는 <strong>CCTV 카메라 또는 NVR</strong>이 본 시스템의 영상 소스입니다.</li>
        <li>각 카메라는 <strong>RTSP 주소</strong>를 통해 스트림을 제공합니다.
          <br>예) <code>rtsp://nvr.local/live/cam01</code>, <code>rtsp://10.0.0.10/stream/2</code>
        </li>
        <li>프로젝트는 <strong>카메라 자체를 교체하지 않고</strong>, 이미 운영 중인 CCTV를 “끌어와서 보는” 구조입니다.</li>
        <li>RTSP 주소와 카메라 이름/위치는 <strong>DB의 CCTV 관리 테이블</strong>에 저장되고,
          FE의 CCTV 관리 탭에서 조회/수정할 수 있습니다.</li>
      </ul>
    </div>

    <div class="section">
      <h2>3. AI 레이어 – 화재 감지 서버</h2>
      <p>AI 레이어는 RTSP 영상을 받아 화재 여부를 판별하는 역할을 담당합니다.</p>
      <ul>
        <li>AI 서버는 Docker 컨테이너로 동작하며, 내부에
          <strong>화재 감지 모델(YOLO 계열 등)</strong>과
          <strong>스트림 처리 로직(OpenCV 등)</strong>이 포함됩니다.
        </li>
        <li>각 CCTV 스트림에 대해 일정 주기로 프레임을 추출하고, 모델 추론을 수행합니다.</li>
        <li>
          일정 시간 이상, 설정된 신뢰도(confidence) 이상으로 화재가 감지되면
          <strong>“화재 감지 이벤트”</strong>로 간주하고,
          BE 서버로 이벤트 정보를 전송합니다.
        </li>
        <li>전송 방식은 내부용 REST API 호출을 기본으로 합니다.
          <br>예) <code>POST /internal/events/fire</code>
        </li>
        <li>필요 시 향후에는 메시지 큐(Kafka, RabbitMQ 등)로 확장할 수 있지만,
          현재 프로젝트 범위에서는 <strong>간단한 HTTP 호출 구조</strong>를 사용합니다.</li>
      </ul>
    </div>

    <div class="section">
      <h2>4. 백엔드 레이어 – API / 비즈니스 로직 / WebSocket / 카카오</h2>

      <h3>4-1. API 서버 (REST)</h3>
      <ul>
        <li>FastAPI 기반의 백엔드 서버가 <strong>REST API</strong>를 제공합니다.</li>
        <li>주요 역할:
          <ul>
            <li>AI 서버로부터 화재 이벤트 수신</li>
            <li>이벤트 로그, CCTV 정보, 사용자 정보 등 DB 액세스</li>
            <li>프론트엔드 대시보드에서 사용하는 조회/필터링 API 제공</li>
            <li>관리 기능(CCTV 등록/수정, 템플릿 관리 등) 처리</li>
          </ul>
        </li>
        <li>엔드포인트 예:
          <ul>
            <li><code>GET /api/events</code> – 이벤트 목록 조회</li>
            <li><code>GET /api/cctvs</code> – CCTV 목록 조회</li>
            <li><code>POST /internal/events/fire</code> – AI → BE 내부 화재 이벤트 보고</li>
          </ul>
        </li>
      </ul>

      <h3>4-2. 비즈니스 로직</h3>
      <ul>
        <li>AI에서 받은 이벤트를 토대로 <strong>단계(level)</strong>를 판정하고,
          <strong>중복/오탐/지속 시간</strong>을 고려해 최종 이벤트 상태를 관리합니다.</li>
        <li>이전 장에서 정의한 <strong>이벤트 처리 전체 플로우</strong>에 따라:
          <ul>
            <li>새 이벤트 생성 또는 기존 이벤트 갱신</li>
            <li>상태(Active/Resolved/Canceled) 업데이트</li>
            <li>카카오 발송 여부 결정</li>
            <li>WebSocket을 통한 실시간 알림 발행</li>
          </ul>
        </li>
      </ul>

      <h3>4-3. WebSocket 서버</h3>
      <ul>
        <li>BE와 동일한 애플리케이션 또는 별도 엔드포인트로 <strong>WebSocket 서버</strong>를 운영합니다.</li>
        <li>주요 기능:
          <ul>
            <li>새로운 화재 이벤트 발생 시, 대시보드에 실시간 푸시</li>
            <li>이벤트 단계 상승/해제(Resolved) 상태 변경 알림</li>
            <li>로그/통계 탭의 실시간 업데이트를 위한 이벤트 스트림 제공</li>
          </ul>
        </li>
        <li>FE는 접속 시 <strong>인증/권한 체크</strong> 후, 프로젝트에서 정의한
          JSON 메시지 포맷으로 이벤트를 수신합니다.</li>
      </ul>

      <h3>4-4. 카카오 연동 모듈</h3>
      <ul>
        <li>카카오 알림톡 또는 플러스친구 발송을 담당하는 <strong>어댑터 모듈</strong>이 백엔드 내부에 존재합니다.</li>
        <li>이 모듈은:
          <ul>
            <li>사전에 등록된 템플릿 ID, 발신 프로필, 수신자 정보 등을 이용해</li>
            <li>“화재 단계”, “장소”, “시간”, “이미지 URL” 등을 템플릿에 바인딩하고</li>
            <li>카카오 발송 API(또는 연동 대행사 API)를 호출합니다.</li>
          </ul>
        </li>
        <li>발송 결과(성공/실패)는 DB에 기록되어, 추후 로그 조회나 재전송 정책에 활용됩니다.</li>
      </ul>
    </div>

    <div class="section">
      <h2>5. 데이터 레이어 – DB 및 파일 스토리지</h2>
      <p>데이터 레이어는 <strong>MySQL DB</strong>와 <strong>이벤트 이미지 저장소</strong>로 구성됩니다.</p>

      <h3>5-1. MySQL 데이터베이스</h3>
      <ul>
        <li>DB는 Docker 컨테이너로 실행되는 <strong>MySQL</strong>을 사용합니다.</li>
        <li>주요 테이블:
          <ul>
            <li>CCTV 정보 테이블 (카메라 ID, 이름, 위치, RTSP URL 등)</li>
            <li>이벤트 로그 테이블 (event_type, level, status, 시간, 카카오 전송 상태 등)</li>
            <li>카카오 전송 이력 테이블(선택 사항)</li>
            <li>사용자/관리자 계정, 템플릿 설정 등</li>
          </ul>
        </li>
        <li>DB 구조와 정규화 내용은 <strong>DB &amp; ERD 챕터</strong>에서 상세히 다룹니다.</li>
      </ul>

      <h3>5-2. 이미지/파일 저장소</h3>
      <ul>
        <li>AI 서버 또는 BE 서버에서 <strong>화재 감지 시 캡처한 이미지</strong>를 파일로 저장합니다.</li>
        <li>이미지 파일 자체는 서버 로컬 디스크, NAS, 혹은 별도 스토리지에 저장될 수 있습니다.</li>
        <li>DB에는 이미지의 <strong>경로 또는 URL</strong>만 저장합니다.
          <br>예) <code>/events/2025-12-11/CCTV-001_102345.jpg</code></li>
        <li>프론트엔드는 이 경로를 이용해 이벤트 상세 화면에서 이미지를 조회합니다.</li>
      </ul>
    </div>

    <div class="section">
      <h2>6. 프론트엔드 레이어 – Vue 대시보드와 Nginx</h2>

      <h3>6-1. Vue 기반 관리자 대시보드</h3>
      <ul>
        <li>프론트엔드는 <strong>Vue</strong>를 기반으로 한 SPA(Single Page Application) 구조입니다.</li>
        <li>주요 화면:
          <ul>
            <li>메인 대시보드 – 그룹별 요약, 각 그룹의 상태, 알림 카운트</li>
            <li>서브 대시보드 – 선택 그룹 내 최대 16개의 CCTV 카드 및 실시간 상태</li>
            <li>로그 &amp; 통계 탭 – 이벤트 리스트, 필터, 차트</li>
            <li>CCTV 관리 탭 – 카메라 등록/수정, 메인 지정</li>
            <li>마이페이지 – 카카오 연동 상태, 알림 템플릿 설정 등</li>
          </ul>
        </li>
        <li>FE는:
          <ul>
            <li>REST API를 통해 데이터 조회/조작을 수행하고,</li>
            <li>WebSocket을 통해 실시간 이벤트를 수신합니다.</li>
          </ul>
        </li>
      </ul>

      <h3>6-2. Nginx 정적 파일 서버</h3>
      <ul>
        <li>빌드가 완료된 Vue 앱은 <strong>Nginx 컨테이너</strong>에서 정적 파일로 서비스됩니다.</li>
        <li>Nginx는:
          <ul>
            <li><code>/</code> 경로로 들어온 요청에 대해 Vue 앱(정적 파일)을 반환하고,</li>
            <li><code>/api</code>, <code>/ws</code> 등 백엔드 경로는 <strong>리버스 프록시</strong>로 BE 컨테이너에 전달합니다.</li>
          </ul>
        </li>
        <li>이 구조를 통해, 외부 사용자는 <strong>하나의 도메인/포트</strong>만 바라보면서
          FE, API, WebSocket을 모두 이용할 수 있습니다.</li>
      </ul>
    </div>

    <div class="section">
      <h2>7. 인프라 레이어 – Docker / Docker Compose 통합 구조 개요</h2>
      <p>
        인프라 레이어에서는 전체 구성 요소가 <strong>Docker Compose</strong>를 통해 하나의 세트로 실행됩니다.
        세부적인 docker-compose.yml 설정은 <strong>다음 장(운영/배포)</strong>에서 다루고, 여기서는 큰 그림만 설명합니다.
      </p>

      <h3>7-1. 주요 컨테이너 구성</h3>
      <ul>
        <li><strong>ai-server</strong> – RTSP 수신, 화재 감지 모델 실행, BE에 이벤트 전송</li>
        <li><strong>backend-api</strong> – FastAPI 기반 REST API / 비즈니스 로직</li>
        <li><strong>backend-ws</strong> (선택, 또는 backend-api와 통합) – WebSocket 서버</li>
        <li><strong>kakao-adapter</strong> (선택, 또는 backend-api 내부 모듈) – 카카오 발송 처리</li>
        <li><strong>db</strong> – MySQL 데이터베이스</li>
        <li><strong>frontend</strong> – Vue 앱 정적 파일을 서빙하는 Nginx</li>
      </ul>

      <h3>7-2. 컨테이너 간 기본 연결 관계</h3>
      <ul>
        <li>ai-server → backend-api
          <ul>
            <li>HTTP 내부 호출로 화재 이벤트 전송</li>
          </ul>
        </li>
        <li>backend-api ↔ db
          <ul>
            <li>이벤트 로그, CCTV 정보, 카카오 이력 등 RDB 저장/조회</li>
          </ul>
        </li>
        <li>backend-api / backend-ws → frontend
          <ul>
            <li>프론트엔드는 API, WebSocket 엔드포인트를 사용</li>
          </ul>
        </li>
        <li>backend-api → kakao-adapter
          <ul>
            <li>카카오 발송 요청 전달 및 결과 수신</li>
          </ul>
        </li>
      </ul>
    </div>

    <div class="section">
      <h2>8. 로컬 / 운영 환경에서의 배치 개념</h2>
      <p>배포/운영의 세부 설정은 다음 장에서 다루지만, 기본 개념은 다음과 같습니다.</p>
      <ul>
        <li><strong>로컬 개발 환경</strong>
          <ul>
            <li>개발자는 Docker Compose로 모든 컨테이너를 로컬에서 실행</li>
            <li>테스트용 RTSP 소스(샘플 영상, 파일 등)를 사용해 전체 플로우 검증</li>
          </ul>
        </li>
        <li><strong>테스트/운영 환경</strong>
          <ul>
            <li>실제 CCTV RTSP 주소를 사용</li>
            <li>동일한 docker-compose 또는 K8s 등으로 이식 가능하도록 설계</li>
            <li>DB, 로그, 이미지 스토리지는 백업/보안 정책에 맞게 운영</li>
          </ul>
        </li>
      </ul>

      <p>
        여기까지가 본 프로젝트의 <strong>통합 아키텍처 개요</strong>입니다.
        다음 장에서는 이 구조를 실제로 어떻게 실행하고 운영할지,
        <strong>Docker Compose 설정과 배포/운영 관점</strong>에서 자세히 설명합니다.
      </p>
    </div>

  </div>
</body>
</html>
